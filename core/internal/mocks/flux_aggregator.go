// Code generated by mockery v2.5.1. DO NOT EDIT.

package mocks

import (
	bind "github.com/ethereum/go-ethereum/accounts/abi/bind"
	common "github.com/ethereum/go-ethereum/common"

	contracts "github.com/smartcontractkit/chainlink/core/services/eth/contracts"

	mock "github.com/stretchr/testify/mock"
)

// FluxAggregator is an autogenerated mock type for the FluxAggregator type
type FluxAggregator struct {
	mock.Mock
}

// Address provides a mock function with given fields:
func (_m *FluxAggregator) Address() common.Address {
	ret := _m.Called()

	var r0 common.Address
	if rf, ok := ret.Get(0).(func() common.Address); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	return r0
}

// GetOracles provides a mock function with given fields: opts
func (_m *FluxAggregator) GetOracles(opts *bind.CallOpts) ([]common.Address, error) {
	ret := _m.Called(opts)

	var r0 []common.Address
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) []common.Address); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]common.Address)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LatestRoundData provides a mock function with given fields: opts
func (_m *FluxAggregator) LatestRoundData(opts *bind.CallOpts) (contracts.FluxAggregatorRoundData, error) {
	ret := _m.Called(opts)

	var r0 contracts.FluxAggregatorRoundData
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) contracts.FluxAggregatorRoundData); ok {
		r0 = rf(opts)
	} else {
		r0 = ret.Get(0).(contracts.FluxAggregatorRoundData)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// OracleRoundState provides a mock function with given fields: opts, oracle, roundID
func (_m *FluxAggregator) OracleRoundState(opts *bind.CallOpts, oracle common.Address, roundID uint32) (contracts.FluxAggregatorRoundState, error) {
	ret := _m.Called(opts, oracle, roundID)

	var r0 contracts.FluxAggregatorRoundState
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, common.Address, uint32) contracts.FluxAggregatorRoundState); ok {
		r0 = rf(opts, oracle, roundID)
	} else {
		r0 = ret.Get(0).(contracts.FluxAggregatorRoundState)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts, common.Address, uint32) error); ok {
		r1 = rf(opts, oracle, roundID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}
